#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
:mod:`core.data_structures` [subpackage]

Classes representing data structures used in the analysis.

**Content and Functionalities of Data Structures**

Data structures are designed to store and manipulate the data sets used in the analysis.

- Each *class* represents one *family* of data structures, which corresponds to one milestone in the
  analysis.
  Examples: raw spikes, population firing rates, decoder models...
- Each *instance* of such a class represents one *specific* data set within the family.
  Examples: raw spikes of *one unit* in *one session*.

Each data structure object encapsulates :

- Actual data values to analyze
- Coordinates associated to the dimensions, used to index the data
- General metadata describing the constraints inherent to the data set family (e.g. dimension names)
- Specific metadata describing the unique properties of the data set instance (e.g. session ID)
- Methods relevant to manipulate the data, specifically to load and save data from/to files


**Create and Load Data Structures**

A data structure object can be obtained via two pathways :

+-----------+--------------------------------------+--------------------------------------+
|           | Loading data from a file             | Creating data from scratch           |
+===========+======================================+======================================+
| Approach  | ``Data(...).load()``                 | ``Data(..., data, **coords)``        |
|           | with minimal arguments               | with additional arguments to pass    |
|           | to build the path to the file        | data and coordinate values           |
+-----------+--------------------------------------+--------------------------------------+
| Use Cases | - To recover data at the start       | - To create the final product at     |
|           |   of a processing pipeline           |   the end of a processing pipeline   |
|           | - To visualize data contents         | - To test functions with custom data |
+-----------+--------------------------------------+--------------------------------------+


Modules
-------
:mod:`core.data_structures.base`


Implementation
--------------
Interactions with Coordinates - Dependency Injection
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Data structures store coordinates, which have to be instantiated *outside* of the data constructors
and passed as arguments. This constraint reduces coupling between :class:`Data` and the specific
:class:`Coordinate` classes.

IO-Handling - Strategy Design Pattern
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Data structures delegate certain operations to external classes :

- :class:`PathRuler` subclasses for path generation.
- :class:`Loader` and :class:`Saver` subclasses for loading/saving data in specific file formats.

To interact with those external classes, data classes store instances of the appropriate objects
among their attributes.

Uniform Interface for Data Structures
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

All data structures adhere to a *uniform* interface, which is used throughout the package to
interact with data consistently. This interface is established though a combination of:

- A metaclass :class:`DataStructMeta`:
  Sets *class-level* attributes related to the dimensions and coordinates of any data structure.
- An abstract base class :class:`Data`:
  Defines methods and attributes shared by all the specific data structures.

Implementing Specific Data Structures
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Each *specific* data structure is implemented as a concrete subclass which inherits from
:class:`Data`.

To be valid, each data structure subclass must perform the following steps:

Define Intrinsic Dimensions and Coordinates
...........................................

- Specify two class-level attributes in the subclass body: :attr:`dim2coord` and :attr:`coord2type`.
- Other class-level attributes (:attr:`dims`, :attr:`coords`, :attr:`coord2dim`) are automatically
  generated by the metaclass to ensure consistency.

Manage Paths specific to this Data Structure
............................................

- In the class-level attribute :attr:`path_ruler`, select the appropriate path manager among the
  :class:`PathRuler` subclasses.
- Implement the abstract property :meth:`path`accordingly. It should provide to this path
  manager method :meth:`get_path` all the arguments it requires from the attributes of the data
  structure.

Customize Loading and Saving (Optional)
.......................................

- Change the attributes :attr:`loader` and :attr:`saver` if needed.
- Override :meth:`load` and :meth:`save` methods to transform data into the format expected by the
  loader or saver. To preserve the interface, the method :meth:`load` should not admit any
  additional argument.

By default, the data is handled with :mod:`pickle`, which allows to recover it as an instance of
:class:`Data` and to save it directly without any transformation.

Implement a Custom Constructor
..............................

Responsibilities are shared between the base class and the subclass constructors.

The base class constructor handles the assignment of data and coordinates. It ensures that the
arguments are consistent and fulfill the constraints specified by the class attributes.

Each subclass constructor extends the base class constructor. Each subclass constructor should admit
two types of arguments:

1. *Required* arguments corresponding to the minimal metadata for the path loader associated with
   the data subclass.
   Those arguments are set as attributes by the *subclass constructor* itself.
2. *Optional* arguments for data values (``data``) and coordinates (matching the names defined in
   the class attributes).
   Those attributes are set as attributes by the *base class constructor*. Coordinates have to be
   passed to this base class constructor as keyword arguments.

Examples
--------
Define a data structure subclass with a time dimension and a trial dimension associated with three
coordinates: task, context and stimulus.

.. code-block:: python

    class ExampleData(Data):
        dim2coord = MappingProxyType({
        "time": frozenset(["time"]),
        "trials": frozenset(['task', 'ctx', 'stim'])
        })
        coord2type = MappingProxyType({
            'time': CoordTime,
            'task': CoordTask,
            'ctx': CoordCtx,
            'stim': CoordStim,
        }
        path_ruler = PathRulerExample

        def __init__(self,
                    id_: str,
                    data: Optional[npt.NDArray] = None,
                    time: Optional[CoordTime] = None,
                    task: Optional[CoordTask] = None,
                    ctx: Optional[CoordCtx] = None,
                    stim: Optional[CoordStim] = None,
                    ) -> None:

            # Assign subclass-specific metadata
            self.id = id_
            # Call the base class constructor to handle data and coordinates
            super().__init__(data, time=time, task=task, ctx=ctx, stim=stim)

        # Implement the path by calling the path manager method with the required arguments
        @property
        def path(self):
            return self.path_ruler().get_path(self.id)

See Also
--------
:mod:`core.coordinates`
    Coordinate classes representing the dimensions of the data structures.
:mod:`utils.storage_rulers`
    PathRuler classes implementing path generation rules for each data class.
:meth:`utils.io_data.loaders`
    Loader classes used to load data from files in various formats.
:meth:`utils.io_data.saver`
    Saver classes used to save data to files in a format determined by the data type itself.
"""
