#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
`core.builders.build_ensembles` [module]

Classes
-------
`EnsemblesBuilder`
"""
# pylint: disable=missing-function-docstring

from typing import List

import numpy as np

from core.builders.base_builder import CoordinateBuilder
from core.coordinates.bio_info_coord import CoordUnit
from core.processors.preprocess.assign_ensembles import EnsembleAssigner, Ensembles
from core.entities.bio_info import Unit


class EnsemblesBuilder(CoordinateBuilder[CoordUnit]):
    """
    Build ensembles of units to form pseudo-populations for cross-validation.

    Product: `CoordUnits`

    Class Attributes
    ----------------
    PRODUCT_CLASS : type
        See the base class attribute.
    TMP_DATA : Tuple[str]
        See the base class attribute.

    Configuration Parameters
    ------------------------
    ensemble_size : int
        Number of units required to form each ensemble (imposed by the area with the lowest number
        of units).
    n_ensembles_max : int
        Maximum number of ensembles to form from the population (to limit the number of ensembles
        and computational cost for the areas with the largest populations).

    Processing Attributes
    ---------------------
    units : List[Unit]
        Units in the population. Each element behaves like a string, representing the unit's
        identifier.
    seed : int
        Seed for the random number generator, used in the ensemble assignment.

    Methods
    -------
    `build` (required)
    `generate_ensembles`
    `construct_coord`

    Examples
    --------
    Set the number of units in each ensemble (size) and the maximum number of ensembles:

    >>> builder = EnsemblesBuilder(ensemble_size=20, n_ensembles_max=10)

    Generate ensembles for a population of units:

    >>> builder.build(units=units, seed=0)

    """

    PRODUCT_CLASS = CoordUnit
    TMP_DATA = ("data_per_unit", "seed", "ensembles")

    def __init__(self, ensemble_size: int, n_ensembles_max: int) -> None:
        # Call the base class constructor: declare empty product and internal data
        super().__init__()
        # Store configuration parameters
        self.ensemble_size = ensemble_size
        self.n_ensembles_max = n_ensembles_max

    def build(self, units: List[Unit] | None = None, seed: int = 0, **kwargs) -> CoordUnit:
        """
        Implement the base class method.

        Parameters
        ----------
        units : List[Unit]
            See the attribute `units`.
        seed : int
            See the attribute `seed`.

        Returns
        -------
        ensembles : Ensembles
            Indices of the units in each ensemble. Shape: ``(n_ensembles, ensemble_size)``.
        """
        if units is None:
            units = []
        n_units = len(units)
        ensembles = self.generate_ensembles(n_units, seed)
        self.product = self.construct_coord(units, ensembles)
        return self.get_product()

    def generate_ensembles(self, n_units: int, seed: int = 0) -> Ensembles:
        """
        Generate the ensembles of units to form the pseudo-population.

        Returns
        -------
        ensembles : Ensembles
            See the attribute generated by this method.

        See Also
        --------
        `EnsembleAssigner`
        """
        assigner = EnsembleAssigner(self.ensemble_size, self.n_ensembles_max)
        ensembles = assigner.process(n_units=n_units, seed=seed)
        return ensembles

    def construct_coord(self, units: List[Unit], ensembles: Ensembles) -> CoordUnit:
        """
        Construct the units coordinate for the pseudo-population (unit labels in each ensemble).

        Returns
        -------
        units : CoordUnit
            See the attribute `units` in the data structure product.

        Warning
        -------
        Two indices are used to identify the units in the population:

        - ``u_pop``: index of the unit in the population list (from 0 to ``n_units``).
        - ``u_ens``: index of the unit in the ensemble (from 0 to ``ensemble_size``).

        Implementation
        --------------
        Advanced indexing and broadcasting:

        ``coord[:, :] = np.array(units)[ensembles]``

        - Select elements from the units array using the indices specified in ensembles.
        - Broadcast the units array to the shape of ensembles.

        """
        n_ensembles, _ = ensembles.shape
        coord = CoordUnit(np.full((n_ensembles, self.ensemble_size), "", dtype=np.str_))
        coord[:, :] = np.array(units)[ensembles]
        return coord
